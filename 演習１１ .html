<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
    </head>
    <style>
        table, th, td {
          border:1px solid black;
        }
        img{
            width: 80%;
        }
        body{
            max-width: 80%;
            margin: auto;
            padding: 10px;
        }

    </style>
<body>

<h1>関数の中のスタックの概念、データのやりとりの方法を調査しろ。</h1>

<div>
    <h2>スタック</h2>
        <p>コンピュータ用語としての一般的なスタックは、以下の図の構造を持つものです。</p>
            <li>複数のデータを格納できる入れ物(バケツのようなイメージ)</li>
            <li>データを格納するときは一番上に積む(push)</li>
            <li>データを取り出すときは、一番上に積まれているものを取り出す(pop)</li>
        
        <img src="https://tonkun-tech.com/wp-content/uploads/2021/06/0_push_pop-1-768x446.png">


        <P>データの構造からLIFO(Last In First Out)とも表現されます。名前の通り、最後に入れたものを最初に取り出す、という意味です。<br/>
        先に入れたものを取り出すためには、上に積まれたものを先にすべて取り出す必要があります。</P>
</div>

<div>
    <h2>スタックメモリ</h2>
        <table>
            <tr>
                <td>プログラムメモリ</td>
                <td>関数・定数</td>
                <td>R</td>
                <td>大サイズ</td>
                <td>関数や定数が配置</td>
            </tr>
            <tr style="color: blue;">
                <td>スタックメモリ</td>
                <td>変数</td>
                <td>R／W</td>
                <td>小サイズ</td>
                <td>関数内で定義した変数が配置</td>
            </tr>
            <tr>
                <td>静的メモリ</td>
                <td>変数</td>
                <td>R／W</td>
                <td>中サイズ</td>
                <td>関数外で定義した変数が配置</td>
            </tr>
            <tr>
                <td>動的メモリ</td>
                <td>変数</td>
                <td>R／W</td>
                <td>大サイズ</td>
                <td>メモリ確保関数で取得</td>
            </tr>
        </table>

        <p>他のメモリに対して、サイズが小さいのが特徴的です。</p>

        <p><b>スタックメモリは、関数内で定義されたローカル変数が配置されるメモリです。</b></p>
        <p>ローカル変数の特徴は、関数が呼び出されると変数ラベルが貼られ、関数が呼び終わると変数ラベルが自動的に破棄されることです。</p>
</div>

<div>
    <h2>スタックメモリの簡易イメージ図</h2>
        <img src="https://monozukuri-c.com/wp-content/uploads/2019/08/dfb2863f7e432558c9cb831b7b887159-1.png">
        <p>メモリの番地に着目してください。「スタックメモリ」は大きな番地から小さな番地に向けて進んでいくんです。</p>
</div>

<div>
    <h2>スタックメモリが実際に使用されるイメージ図</h2>
        <p>関数「funcA」「funcB」「funcC」が、順に呼ばれることを想定します。<br/>
        関数が順に呼ばれると、次のようにスタックメモリは伸長します。</p>
        <img src="https://monozukuri-c.com/wp-content/uploads/2019/08/51a4c8d2cc3bb4dd14fdc418fe4e5ec7.png">
        <p>続いて関数「funcC」「funcB」「funcA」の順に関数呼び出しが終了すると、次のように収縮していきます。</p>
        <img src="https://monozukuri-c.com/wp-content/uploads/2019/08/66ad6adb7210ab957dcfc18d1ede68b8.png">
        <p>プログラムが動作している間は関数呼び出しと呼び出し終了に伴い、スタックメモリはこのように伸縮しながらメモリを使用しているのです。<br/>
        ローカル変数のラベルはスタック機構により、関数呼び出しによりスタックに貼られ、関数呼び出しが終わるとスタックから剥がされるのです。<br/>
        お皿が順に積まれて、取り出される動きになっていますよね。これがスタックメモリです。</p>
</div>

<div>
    <h2>スタックオーバーフローに注意せよ</h2>
        <p>スタックメモリとして使用できるメモリサイズは、あらかじめ決まっています。<br/>
        Windowsアプリケーションであれば、スタックメモリは１Mバイト程度と比較的大きく割り当てられるのですが、組み込み開発のスタックメモリは数キロバイトといったことも珍しくありません。<br/>
        そのため、組み込み開発では不用意にローカル変数をたくさん確保すると、あっという間にスタックメモリを食いつぶしてしまいます。</p>
        <img src="https://monozukuri-c.com/wp-content/uploads/2019/08/aefe18edcb576da010e9f1e5ebed05d0.png">
        <p>このように決められたスタックサイズ以上に、スタックメモリを使用することを「スタックオーバーフロー」と呼びます。<br/>
        スタックオーバーフローはビルド時にエラー検出ができず、実行時に発生します。<br/>
        もしもスタックオーバーフローが発生した場合、システムはクラッシュします。<br/>
        自分以外の誰かが定義した構造体を、ローカル変数で使用する場合は特に注意が必要です。<br/>
        思わぬメモリサイズが消費されている可能性がありますので、事前にsizeof演算子で構造体サイズを確認するといったことは効果的な方法です。<br/>
        関数の引数も、ローカル変数なのでスタックを利用します。<br/>
        大きなサイズの構造体を引数で値渡しするとスタックを消費するため、意図的にポインタ渡しにすることでスタック消費を抑えるテクニックがあります。</p>
</div>

    <footer>
        <p>Page References</p>
        <p><a href="https://tonkun-tech.com/embedded_stack/">【C言語組み込み】スタックって何？</a></p>
        <p><a href="https://monozukuri-c.com/langc-stack-memory/">C言語 スタックメモリ【ローカル変数が確保される仕組みを解説】</a></p>
    </footer>

</body>
</html>

